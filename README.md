# one_man_knowledgebase

## Computer science


## C++

### Trailing return type

```cpp

auto foo(int x, int y) -> int;
int foo2(int x, int y);
```

Это абсолютно равнозначные записи и смысла так писать нет, однако, если тип необходимо вывести из аргументов функции, то можно использовать decltype в этом подходе

```cpp
auto foo(int x, int y) -> decltype(x + y);
```

Тогда тип возвращаемое значения будет выведен из типа результа операции, тут семантика в том, что после объявления принимаемых аргументов функции они становяться доступны для компилятора.

Но в С++ 14 появилась запись
```cpp
decltype(auto) foo(int x, int y) {
    return x + y;
}
```

Что убирает необходимость в написии -> decltype(использование аргументов)

## LLD pattern and paradigms

### CRTP pattern

Паттерн призван убрать вызовы виртуальных методов наследников в runtime и сделать возможным полиморфизм, используя шаблоны, т.е полиморфизм в compile time.

Для того, чтобы реализовать этот паттерн необходимо создать базовый класс и сделать его шаблонным.  В этом классе должен быть метод, который будет кастовать this к указателю на параметр шаблона. 

В каждой функции базового класса мы будем вызывать методы класса наследника, за счет этого, если в классе наследнике не реализован вызываемый метод, то мы получим ошибку на этапе компиляции.

Наследник должен наследоваться от базового шаблонного класса, параметризируя собой же шаблонный параметр базового класса.

Пример реализации находиться в папке examples/crpt_pattern.




